package main

import (
	"bytes"
	"fmt"
	"os"
	"strings"

	"go/ast"

	"golang.org/x/exp/ebnf"
	"golang.org/x/tools/go/packages"
)

// EBNFGrammar is a type for a grammar defined in EBNF.
type EBNFGrammar struct {
	pkgname string
	Name    string
	Start   string
	ebnf    ebnf.Grammar
}

// LoadEBNFFromComment searches for an EBNF grammar in a comments section of
// Go source files, given a package name. If found, will return an instance
// of EBNFGrammar with the grammar parsed.
// If no grammar has been found or parsing an existing grammar resulted in an
// error, an error is returned.
func LoadEBNFFromComment(grammarname string, pkgname string) (*EBNFGrammar, error) {
	cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedSyntax}
	pkgs, err := packages.Load(cfg, pkgname)
	if err != nil {
		fmt.Fprintf(os.Stderr, "load: %v\n", err)
		return nil, err
	}
	if packages.PrintErrors(pkgs) > 0 {
		return nil, err
	}
	// for _, pkg := range pkgs { // print name of source files
	// 	fmt.Println(pkg.ID, pkg.GoFiles)
	// }
	for _, pkg := range pkgs {
		for _, ast := range pkg.Syntax {
			for _, commentgroup := range ast.Comments {
				ebnfsnippet, gname, ok := findEBNF(commentgroup)
				if ok && grammarname == gname {
					reader := strings.NewReader(ebnfsnippet)
					g, err := ebnf.Parse(grammarname, reader)
					if err != nil {
						return nil, fmt.Errorf("Could not parse EBNF: %v", err)
					}
					startsym := strings.TrimSpace(ebnfsnippet[:strings.Index(ebnfsnippet, "=")])
					// if err = ebnf.Verify(g, startsym); err != nil {
					// 	return nil, fmt.Errorf("Error verifying grammar: %v", err)
					// }
					return &EBNFGrammar{
						pkgname: pkg.ID,
						Name:    gname,
						Start:   startsym,
						ebnf:    g,
					}, nil
				}
			}
		}
	}
	return nil, fmt.Errorf("No EBNF comments found in package")
}

// findEBNF scans through a comment for an EBNF section.
func findEBNF(cg *ast.CommentGroup) (string, string, bool) {
	directive := cg.List[0].Text
	if strings.HasPrefix(directive, "//grammy ") {
		cg.List[0].Text = "//" // purge the directive from EBNF code
		fmt.Printf("EBNF found:\n%s\n", cg.Text())
		return cg.Text(), parseDirective(directive), true
	}
	return "", "", false
}

// parseDirective searches for "-grammar <Name>" the directive string
// and returns <name>, or "G" if none has been found.
func parseDirective(directive string) string {
	s := strings.Split(directive, " ")
	var grammarname string
	for i, seg := range s {
		if seg == "-grammar" && len(s) > i+1 {
			grammarname = s[i+1]
		}
	}
	if len(grammarname) == 0 {
		return "G"
	}
	return grammarname
}

// --- Grammar Generation -----------------------------------------------

type generator struct {
	buf     bytes.Buffer
	g       *EBNFGrammar
	rules   map[string][]rule
	counter int
}

type rule struct {
	lhs     string
	symbols []string
}

func newRule(lhs string) *rule {
	return &rule{
		lhs:     lhs,
		symbols: make([]string, 0, 10),
	}
}

// GenerateBuilder generates Go source code for a grammar builder.
func GenerateBuilder(g *EBNFGrammar) (string, error) {
	gen := &generator{g: g}
	gen.Printf("// Code generated by \"ebnfcom -grammar %s\"; DO NOT EDIT.\n", g.Name)
	gen.Printf("package %s\n\n", basepkgname(g.pkgname))
	gen.Printf("import \"github.com/npillmayer/gotype/syntax/lr\"\n\n")
	gen.Printf("func MakeGrammar%s() (*lr.Grammar, error) {\n", gen.g.Name)
	gen.Printf("    b := lr.NewGrammarBuilder(\"%s\")\n", gen.g.Name)
	// b.LHS("S").T("a", scanner.Ident).End()
	// b.LHS("S").Epsilon()
	gen.GenerateRules()
	gen.Printf("    g, err := b.Grammar()\n")
	gen.Printf("    if err != nil {\n")
	gen.Printf("        return nil, err\n")
	gen.Printf("    }\n")
	gen.Printf("    return g, nil\n")
	gen.Printf("}\n")
	return gen.buf.String(), nil
}

func (gen *generator) GenerateRules() {
	fmt.Printf("// Grammar builder for %d productions\n", len(gen.g.ebnf))
	for _, prod := range gen.g.ebnf {
		//gen.Printf("production.RHS = %v\n", prod.Expr)
		switch expr := prod.Expr.(type) {
		case nil:
			gen.Printf("    b.LHS(\"%s\")", prod.Name.String)
			gen.Printf(".Epsilon()\n")
		case *ebnf.Name:
			gen.Printf("    b.LHS(\"%s\")", prod.Name.String)
			gen.Printf(".N(\"%s\").End()\n", expr.String)
		case *ebnf.Token:
			gen.Printf("    b.LHS(\"%s\")", prod.Name.String)
			gen.Printf(".T(\"%s\").End()\n", expr)
		case ebnf.Alternative:
			for _, alt := range expr {
				gen.RHS(prod.Name.String, alt)
			}
		default:
			gen.RHS(prod.Name.String, expr)
		}
	}
}

func (gen *generator) RHS(lhs string, rhs ebnf.Expression) {
	switch e := rhs.(type) {
	case ebnf.Sequence:
		gen.Sequence(lhs, e)
	case *ebnf.Option:
		gen.Option(e)
	default:
		gen.Printf("repetition and group not supported\n")
	}
}

// func (gen *generator) Alternative(lhs string, rhs ebnf.Expression) {
// 	gen.Printf("    b.LHS(\"%s\")", lhs)
// 	switch alt := rhs.(type) {
// 	case nil:
// 		gen.Printf(".Epsilon()\n")
// 	case *ebnf.Name:
// 		gen.Printf(".N(\"%s\")", alt.String)
// 	case ebnf.Sequence:
// 		gen.Sequence(alt)
// 	}
// 	gen.Printf(".End()\n")
// }

func (gen *generator) Sequence(lhs string, seq ebnf.Sequence) {
	gen.Printf("    b.LHS(\"%s\")", lhs)
	for _, expr := range seq {
		switch e := expr.(type) {
		case *ebnf.Name:
			gen.Printf(".N(\"%s\")", e.String)
		case *ebnf.Token:
			gen.Printf(".T(\"%s\")", e.String)
		case *ebnf.Option:
			gen.Option(e)
		}
	}
	gen.Printf(".End()\n")
}

func (gen *generator) Option(opt *ebnf.Option) {
	switch o := opt.Body.(type) {
	}
}

func (gen *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&gen.buf, format, args...)
}

// GenerateParser generates Go source code for a parser for the given grammar.
func GenerateParser(g *EBNFGrammar) error {
	return nil
}

func basepkgname(pkgname string) string {
	s := strings.Split(pkgname, "/")
	return s[len(s)-1]
}

// ======================================================================
// This is a test comment for the accompanying test cases.
// Please to not edit!

//grammy -grammar G -parser -package github.com/npillmayer/gotype/syntax/lr/ebnfcom
// Production  = name "=" [ Expression ] "." .
// Expression  = Alternative { "|" Alternative } .
// Alternative = Term { Term } .
// Term        = name | token [ "â€¦" token ] | Group | Option | Repetition .
// Group       = "(" Expression ")" .
// Option      = "[" Expression "]" .
// Repetition  = "{" Expression "}" .
