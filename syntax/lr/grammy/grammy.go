package main

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"unicode"

	"go/ast"

	"golang.org/x/exp/ebnf"
	"golang.org/x/tools/go/packages"
)

// EBNFGrammar is a type for a grammar defined in EBNF.
type EBNFGrammar struct {
	pkgname string
	Name    string
	Start   string
	ebnf    ebnf.Grammar
}

// LoadEBNFFromComment searches for an EBNF grammar in a comments section of
// Go source files, given a package name. If found, will return an instance
// of EBNFGrammar with the grammar parsed.
// If no grammar has been found or parsing an existing grammar resulted in an
// error, an error is returned.
func LoadEBNFFromComment(grammarname string, pkgname string) (*EBNFGrammar, error) {
	//cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedSyntax}
	cfg := &packages.Config{Mode: packages.NeedSyntax}
	pkgs, err := packages.Load(cfg, pkgname)
	if err != nil {
		fmt.Fprintf(os.Stderr, "load: %v\n", err)
		return nil, err
	}
	if packages.PrintErrors(pkgs) > 0 {
		return nil, err
	}
	// for _, pkg := range pkgs { // print name of source files
	// 	fmt.Println(pkg.ID, pkg.GoFiles)
	// }
	for _, pkg := range pkgs {
		for _, ast := range pkg.Syntax {
			for _, commentgroup := range ast.Comments {
				ebnfsnippet, gname, ok := findEBNF(commentgroup)
				if ok && grammarname == gname {
					reader := strings.NewReader(ebnfsnippet)
					g, err := ebnf.Parse(grammarname, reader)
					if err != nil {
						return nil, fmt.Errorf("Could not parse EBNF: %v", err)
					}
					startsym := strings.TrimSpace(ebnfsnippet[:strings.Index(ebnfsnippet, "=")])
					// if err = ebnf.Verify(g, startsym); err != nil {
					// 	return nil, fmt.Errorf("Error verifying grammar: %v", err)
					// }
					return &EBNFGrammar{
						pkgname: pkg.ID,
						Name:    gname,
						Start:   startsym,
						ebnf:    g,
					}, nil
				}
			}
		}
	}
	return nil, fmt.Errorf("No EBNF comments found in package")
}

// findEBNF scans through a comment for an EBNF section.
func findEBNF(cg *ast.CommentGroup) (string, string, bool) {
	directive := cg.List[0].Text
	if strings.HasPrefix(directive, "//grammy ") {
		cg.List[0].Text = "//" // purge the directive from EBNF code
		fmt.Printf("EBNF found:\n%s\n", cg.Text())
		return cg.Text(), parseDirective(directive), true
	}
	return "", "", false
}

// parseDirective searches for "-grammar <Name>" the directive string
// and returns <name>, or "G" if none has been found.
func parseDirective(directive string) string {
	s := strings.Split(directive, " ")
	var grammarname string
	for i, seg := range s {
		if seg == "-grammar" && len(s) > i+1 {
			grammarname = s[i+1]
		}
	}
	if len(grammarname) == 0 {
		return "G"
	}
	return grammarname
}

// --- Grammar Generation -----------------------------------------------

type generator struct {
	buf     bytes.Buffer
	g       *EBNFGrammar
	rules   map[string][]*rule
	counter int
}

type rule struct {
	lhs     string
	symbols []string
}

func (r *rule) append(sym string) *rule {
	if sym == "" {
		return r
	}
	if r == nil {
		r = newRule("")
	}
	r.symbols = append(r.symbols, sym)
	return r
}

func newRule(lhs string) *rule {
	return &rule{
		lhs:     lhs,
		symbols: make([]string, 0, 10),
	}
}

func (gen *generator) genRuleCode(r *rule) {
	if len(r.symbols) == 0 {
		gen.Printf("    LHS(\"%s\").Epsilon()\n", r.lhs)
		return
	}
	gen.Printf("    LHS(\"%s\")", r.lhs)
	for _, sym := range r.symbols {
		if isLower(sym) {
			gen.Printf(".T(\"%s\")", sym)
		} else {
			// TODO how to recognize terminals ?
			gen.Printf(".N(\"%s\")", sym)
		}
	}
	gen.Printf(".End()\n")
}

func (gen *generator) appendRule(lhs string, r *rule) {
	if r == nil {
		return
	}
	r.lhs = lhs
	rules, ok := gen.rules[r.lhs]
	if ok {
		rules = append(rules, r)
		gen.rules[r.lhs] = rules
	} else {
		gen.rules[r.lhs] = []*rule{r}
	}
}

// GenerateBuilder generates Go source code for a grammar builder.
func GenerateBuilder(g *EBNFGrammar) (string, error) {
	gen := &generator{g: g, rules: make(map[string][]*rule)}
	gen.Printf("// Code generated by \"ebnfcom -grammar %s\"; DO NOT EDIT.\n", g.Name)
	gen.Printf("package %s\n\n", basepkgname(g.pkgname))
	gen.Printf("import \"github.com/npillmayer/gotype/syntax/lr\"\n\n")
	gen.Printf("func MakeGrammar%s() (*lr.Grammar, error) {\n", gen.g.Name)
	gen.Printf("    b := lr.NewGrammarBuilder(\"%s\")\n", gen.g.Name)
	gen.GenerateRules()
	gen.Printf("    g, err := b.Grammar()\n")
	gen.Printf("    if err != nil {\n")
	gen.Printf("        return nil, err\n")
	gen.Printf("    }\n")
	gen.Printf("    return g, nil\n")
	gen.Printf("}\n")
	return gen.buf.String(), nil
}

func (gen *generator) GenerateRules() {
	fmt.Printf("// Grammar builder for %d productions\n", len(gen.g.ebnf))
	for _, prod := range gen.g.ebnf {
		switch expr := prod.Expr.(type) {
		case ebnf.Alternative:
			for _, alt := range expr {
				gen.RHS(prod.Name.String, alt)
			}
		default:
			gen.RHS(prod.Name.String, expr)
		}
	}
	gen.RulesCode()
}

func (gen *generator) RHS(lhs string, rhs ebnf.Expression) {
	var r *rule
	switch e := rhs.(type) {
	case ebnf.Sequence:
		gen.Sequence(lhs, "", e, 0)
	case *ebnf.Option:
		nonterm := gen.createID()
		r = r.append(nonterm)
		gen.Option(nonterm, e, 0)
	case *ebnf.Group:
		nonterm := gen.createID()
		r = r.append(nonterm)
		gen.Group(nonterm, e, 0)
	case *ebnf.Repetition:
		nonterm := gen.createID()
		r = r.append(nonterm)
		gen.Repetition(nonterm, e, 0)
	case ebnf.Alternative:
		gen.Printf("ERROR: OR-element needs group")
		name := "ERROR"
		r = r.append(name)
	case nil:
		r = newRule(lhs) // epsilon
	case *ebnf.Name:
		r = r.append(e.String)
	case *ebnf.Token:
		r = r.append(e.String)
	default:
		gen.Printf("ERROR: unknown element in RHS\n")
	}
	gen.appendRule(lhs, r)
}

func (gen *generator) Sequence(lhs string, prefix string, seq ebnf.Sequence, nesting int) *rule {
	var r *rule
	if len(prefix) > 0 {
		r = r.append(prefix)
	}
	for _, expr := range seq {
		switch e := expr.(type) {
		case *ebnf.Name:
			r = r.append(e.String)
		case *ebnf.Token:
			r = r.append(e.String)
		case *ebnf.Group:
			nonterm := gen.createID()
			r = r.append(nonterm)
			gen.Group(nonterm, e, 0)
		case *ebnf.Repetition:
			nonterm := gen.createID()
			r = r.append(nonterm)
			gen.Repetition(nonterm, e, 0)
		case *ebnf.Option:
			nonterm := gen.createID()
			r = r.append(nonterm)
			gen.Option(nonterm, e, nesting+1)
		case ebnf.Alternative:
			gen.Printf("ERROR: OR-element needs group")
			name := "ERROR"
			r = r.append(name)
		}
	}
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Group(lhs string, grp *ebnf.Group, nesting int) *rule {
	var r *rule
	switch e := grp.Body.(type) {
	case *ebnf.Name:
		r = r.append(e.String)
	case *ebnf.Token:
		r = r.append(e.String)
	case *ebnf.Group:
		name := "ERROR: nested groups"
		r = r.append(name)
	case *ebnf.Repetition:
		r = r.append("ERROR: repetition element in group")
	case *ebnf.Option:
		r = r.append("ERROR: optional element in group")
	case ebnf.Alternative:
		gen.Alternative(lhs, e, nesting+1)
	}
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Repetition(lhs string, rep *ebnf.Repetition, nesting int) *rule {
	var r *rule
	switch o := rep.Body.(type) {
	case *ebnf.Name:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		r = r.append(lhs)
		r = r.append(o.String)
	case *ebnf.Token:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		r = r.append(lhs)
		r = r.append(o.String)
	case *ebnf.Option:
		gen.Printf("Optional element not allowed in repetition.")
	case ebnf.Sequence:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		gen.Sequence(lhs, lhs, o, nesting)
	case *ebnf.Repetition:
		gen.Printf("Nested optional elements not allowed.")
	case ebnf.Alternative:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		r = r.append(lhs)
		// for _, expr := range o {
		// 	gen.Alternative(lhs, expr, nesting+1)
		// }
	}
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Alternative(lhs string, alt ebnf.Expression, nesting int) *rule {
	r := newRule(lhs)
	r = r.append("ALTERNATIVE")
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Option(lhs string, opt *ebnf.Option, nesting int) *rule {
	var r *rule
	switch o := opt.Body.(type) {
	case *ebnf.Name:
		r = r.append(o.String)
	case *ebnf.Token:
		r = r.append(o.String)
	case *ebnf.Option:
		gen.Printf("Nested optional elements not allowed.")
	case ebnf.Sequence:
		nonterm := gen.createID()
		r = r.append(nonterm)
		r = gen.Sequence(nonterm, "", o, nesting)
	case *ebnf.Repetition:
		gen.Printf("Nested optional elements not allowed.")
	case ebnf.Alternative:
		name := "invented_AAA"
		r = r.append(name)
		for _, alt := range o {
			gen.Alternative(lhs, alt, nesting+1)
		}
	}
	gen.appendRule(lhs, r)
	r = newRule(lhs)
	gen.appendRule(lhs, r) // add epsilon rule
	return r
}

func (gen *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&gen.buf, format, args...)
}

func (gen *generator) RulesCode() {
	//for lhs, rules := range gen.rules {
	for _, rules := range gen.rules {
		for _, r := range rules {
			//gen.Printf("%.2d: %s => %v\n", i, lhs, r.symbols)
			gen.genRuleCode(r)
		}
	}
}

func (gen *generator) createID() string {
	gen.counter++
	return fmt.Sprintf("N%05d", gen.counter)
}

func isLower(s string) bool {
	return unicode.IsLower(rune(s[0]))
}

// GenerateParser generates Go source code for a parser for the given grammar.
func GenerateParser(g *EBNFGrammar) error {
	return nil
}

func basepkgname(pkgname string) string {
	s := strings.Split(pkgname, "/")
	return s[len(s)-1]
}

// ======================================================================
// This is a test comment for the accompanying test cases.
// Please to not edit!

//grammy -grammar G -parser -package github.com/npillmayer/gotype/syntax/lr/ebnfcom
// Production  = name "=" [ Expression ] "." .
// Expression  = Alternative { "|" Alternative } .
// Alternative = Term { Term } .
// Term        = name | token [ "â€¦" token ] | Group | Option | Repetition .
// Group       = "(" Expression ")" .
// Option      = "[" Expression "]" .
// Repetition  = "{" Expression "}" .
