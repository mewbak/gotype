package main

// https://github.com/wxio/antlr4/blob/visit-runtimeimport-tokenstream/doc/go-target.md
// https://github.com/antlr/antlr4/issues/1843#issuecomment-297849852

import (
	"bytes"
	"fmt"
	"os"

	"github.com/antlr/antlr4/runtime/Go/antlr"
	"github.com/npillmayer/gotype/syntax/mpost/parser"
)

// --- Visitor variation ------------------------------------------------

type PmmpVisitor struct {
	*antlr.BaseParseTreeVisitor

	// result fields
	SExpr bytes.Buffer
}

// Can be used to check that all Visit methods are "overriden"
//var _ parser.pmmpostVisitor = &PmmpVisitor{}

// Filter
/*
func (v *PmmpVisitor) VisitNext(node antlr.Tree) bool {
    // Don't visit terminal node
    if _, ok := node.(antlr.TerminalNode); ok {
        var t antlr.TerminalNode = node.(antlr.TerminalNode)
        fmt.Printf("terminal node is \"%s\"\n"), t.GetText())
        fmt.Printf("terminal node: %v\n", node.GetPayload())
        return false
    }
    // Don't visit rule B is the last rule A token was a 0
        if _, ok := node.(*parser.BContext); !v.lastAis1 && ok {
            return false
        }
    return true
}
*/

// never called because VisitNext filters all TerminalNode types
func (v *PmmpVisitor) VisitTerminal(node antlr.TerminalNode) interface{} {
	fmt.Printf("terminal %v\n", node.GetText())
	return nil
}

func (v *PmmpVisitor) VisitErrorNode(node antlr.ErrorNode) interface{} {
	fmt.Println("Hello ERROR NODE")
	return nil
}

func (v *PmmpVisitor) VisitFigure(ctx *parser.FigureContext) interface{} {
	//fmt.Printf("rule %v\n", node.GetText())
	fmt.Println("Hello FIGURE")
	return v.VisitChildren(ctx)
}

func (v *PmmpVisitor) VisitStatementlist(ctx *parser.StatementlistContext) interface{} {
	//fmt.Printf("rule %v\n", node.GetText())
	fmt.Println("Hello STATEMENT LIST")
	return v.VisitChildren(ctx)
}

func (v *PmmpVisitor) VisitStatement(ctx *parser.StatementContext) interface{} {
	//fmt.Printf("rule %v\n", node.GetText())
	return v.VisitChildren(ctx)
}

func (v *PmmpVisitor) VisitGrouping(ctx *parser.GroupingContext) interface{} {
	//fmt.Printf("rule %v\n", node.GetText())
	return v.VisitChildren(ctx)
}

func (v *PmmpVisitor) VisitHelloworld(ctx *parser.HelloworldContext) interface{} {
	//fmt.Printf("rule %v\n", node.GetText())
	fmt.Println("Hello HELLO WORLD")
	return v.VisitChildren(ctx)
}

/*
func (v *PmmpVisitor) VisitA(ctx parser.IAContext, delegate antlr.ParseTreeVisitor) {
    // before children
    // Don't visit any more children after a "y"
    if v.seenY {
        return
    }
    v.SExpr.WriteString(" (a ")
    v.SExpr.WriteString(ctx.GetT().GetText())
    fmt.Printf("%s\n", ctx.GetT().GetText())
    v.lastAis1 = ctx.GetT().GetText() == "1"
    v.VisitChildren(ctx, delegate)
    // afer children
    v.SExpr.WriteString(")")
}

func (v *PmmpVisitor) VisitB(ctx parser.IBContext, delegate antlr.ParseTreeVisitor) {
    // before children
    v.SExpr.WriteString(" (b ")
    v.SExpr.WriteString(ctx.GetT().GetText())
    fmt.Printf("%s\n", ctx.GetT().GetText())
    v.seenY = ctx.GetT().GetText() == "y"
    v.VisitChildren(ctx, delegate)
    // afer children
    v.SExpr.WriteString(")")
}
*/

// ----------------------------------------------------------------------

func main() {
	input, _ := antlr.NewFileStream(os.Args[1])
	lexer := parser.NewpmmpostLexer(input)
	stream := antlr.NewCommonTokenStream(lexer, 0)
	p := parser.NewpmmpostParser(stream)
	p.AddErrorListener(antlr.NewDiagnosticErrorListener(true))
	p.BuildParseTrees = true
	tree := p.Figure()
	sexpr := antlr.TreesStringTree(tree, nil, p)
	fmt.Printf("%s\n", sexpr)
	v := new(PmmpVisitor)
	tree.Accept(v)
}
